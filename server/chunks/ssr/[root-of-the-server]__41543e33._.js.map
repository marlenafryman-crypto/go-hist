{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/verify-historical-connection.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent for verifying historical connections between cards.\n *\n * - verifyHistoricalConnection - A function that verifies the historical connection explanation.\n * - VerifyHistoricalConnectionInput - The input type for the verifyHistoricalConnection function.\n * - VerifyHistoricalConnectionOutput - The return type for the verifyHistoricalConnection function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst VerifyHistoricalConnectionInputSchema = z.object({\n  card1Name: z.string().describe('The name of the first card.'),\n  card2Name: z.string().describe('The name of the second card.'),\n  explanation: z.string().describe('The explanation of the historical connection between the two cards.'),\n});\nexport type VerifyHistoricalConnectionInput = z.infer<typeof VerifyHistoricalConnectionInputSchema>;\n\nconst VerifyHistoricalConnectionOutputSchema = z.object({\n  isValid: z.boolean().describe('Whether the historical connection explanation is valid.'),\n  reason: z.string().describe('The reasoning behind the validity determination.'),\n});\nexport type VerifyHistoricalConnectionOutput = z.infer<typeof VerifyHistoricalConnectionOutputSchema>;\n\nexport async function verifyHistoricalConnection(input: VerifyHistoricalConnectionInput): Promise<VerifyHistoricalConnectionOutput> {\n  return verifyHistoricalConnectionFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'verifyHistoricalConnectionPrompt',\n  input: {schema: VerifyHistoricalConnectionInputSchema},\n  output: {schema: VerifyHistoricalConnectionOutputSchema},\n  prompt: `You are an expert historian. You will be given two cards, and an explanation of how they are historically connected.\nYour job is to determine whether the explanation is valid, and provide a reason for your determination.\n\nCard 1: {{{card1Name}}}\nCard 2: {{{card2Name}}}\nExplanation: {{{explanation}}}\n\nIs the explanation valid? Answer in the following JSON format:\n{\n  \"isValid\": boolean,\n  \"reason\": string\n}`,\n  config: {\n    safetySettings: [\n      {\n        category: 'HARM_CATEGORY_HATE_SPEECH',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_HARASSMENT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n        threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n      },\n    ],\n  },\n});\n\nconst verifyHistoricalConnectionFlow = ai.defineFlow(\n  {\n    name: 'verifyHistoricalConnectionFlow',\n    inputSchema: VerifyHistoricalConnectionInputSchema,\n    outputSchema: VerifyHistoricalConnectionOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,wCAAwC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrD,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACnC;AAGA,MAAM,yCAAyC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACtD,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAGO,eAAe,2BAA2B,KAAsC;IACrF,OAAO,+BAA+B;AACxC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAAqC;IACrD,QAAQ;QAAC,QAAQ;IAAsC;IACvD,QAAQ,CAAC;;;;;;;;;;;CAWV,CAAC;IACA,QAAQ;QACN,gBAAgB;YACd;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;SACD;IACH;AACF;AAEA,MAAM,iCAAiC,mHAAA,CAAA,KAAE,CAAC,UAAU,CAClD;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAnDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/types.ts"],"sourcesContent":["import {z} from 'genkit';\n\nconst CardSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['Person', 'Event']),\n  description: z.string(),\n});\nexport type Card = z.infer<typeof CardSchema>;\n\nexport const FindMatchingCardInputSchema = z.object({\n  request: z\n    .string()\n    .describe('The textual request for a card from the current player.'),\n  opponentHand: z\n    .array(CardSchema)\n    .describe(\"An array of card objects in the opponent's hand.\"),\n});\nexport type FindMatchingCardInput = z.infer<typeof FindMatchingCardInputSchema>;\n\nexport const FindMatchingCardOutputSchema = z.object({\n  cardId: z\n    .string()\n    .optional()\n    .describe(\n      \"The ID of the card in the opponent's hand that matches the request. If no card matches, this will be undefined.\"\n    ),\n  reason: z\n    .string()\n    .describe(\n      'A brief explanation of why the card matches the request, or why no card matches.'\n    ),\n});\nexport type FindMatchingCardOutput = z.infer<\n  typeof FindMatchingCardOutputSchema\n>;\n\nexport const VerifyHistSetInputSchema = z.object({\n    cards: z.array(CardSchema).length(4).describe('The four cards being checked for a valid Hist Set.'),\n    explanation: z.string().describe('The player\\'s explanation of the historical connection between the four cards.'),\n});\nexport type VerifyHistSetInput = z.infer<typeof VerifyHistSetInputSchema>;\n\nexport const VerifyHistSetOutputSchema = z.object({\n    isValid: z.boolean().describe('Whether the historical connection explanation is valid and follows the rules.'),\n    reason: z.string().describe('The reasoning behind the validity determination.'),\n});\nexport type VerifyHistSetOutput = z.infer<typeof VerifyHistSetOutputSchema>;\n\nexport const VerifyHistoricalConnectionInputSchema = z.object({\n  card1Name: z.string().describe('The name of the first card.'),\n  card2Name: z.string().describe('The name of the second card.'),\n  explanation: z.string().describe('The explanation of the historical connection between the two cards.'),\n});\nexport type VerifyHistoricalConnectionInput = z.infer<typeof VerifyHistoricalConnectionInputSchema>;\n\nexport const VerifyHistoricalConnectionOutputSchema = z.object({\n  isValid: z.boolean().describe('Whether the historical connection explanation is valid.'),\n  reason: z.string().describe('The reasoning behind the validity determination.'),\n});\nexport type VerifyHistoricalConnectionOutput = z.infer<typeof VerifyHistoricalConnectionOutputSchema>;\n\n\nconst AiPlayerInfoSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  handSize: z.number(),\n  histSetCount: z.number(),\n});\n\nexport const GetAiPlayerActionInputSchema = z.object({\n  playerName: z.string().describe(\"The AI player's name.\"),\n  hand: z.array(CardSchema).describe(\"The AI player's current hand.\"),\n  histSetCount: z.number().describe('The number of Hist Sets the AI player has already formed.'),\n  otherPlayers: z.array(AiPlayerInfoSchema).describe('Information about the other players in the game.'),\n  discardTopCard: CardSchema.optional().describe('The card currently on top of the discard pile, if any.'),\n  canWin: z.boolean().describe('Whether forming one more set will win the game.'),\n});\nexport type GetAiPlayerActionInput = z.infer<typeof GetAiPlayerActionInputSchema>;\n\n\nexport const GetAiPlayerActionOutputSchema = z.object({\n  action: z.enum(['formSet', 'ask', 'drawDeck', 'drawDiscard']).describe('The action the AI has decided to take.'),\n  cardIds: z.array(z.string()).optional().describe(\"The IDs of the cards to form a set with. Only present if action is 'formSet'.\"),\n  explanation: z.string().optional().describe(\"The explanation for the Hist Set. Only present if action is 'formSet'.\"),\n  opponentId: z.string().optional().describe(\"The ID of the opponent to ask for a card. Only present if action is 'ask'.\"),\n  request: z.string().optional().describe(\"The card being requested from the opponent. Only present if action is 'ask'.\"),\n});\nexport type GetAiPlayerActionOutput = z.infer<typeof GetAiPlayerActionOutputSchema>;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 414, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/find-matching-card.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent for finding a matching card in a player's hand based on a request.\n *\n * - findMatchingCard - A function that checks if any card in a hand matches a given request.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\nimport {\n  FindMatchingCardInputSchema,\n  FindMatchingCardOutputSchema,\n  type FindMatchingCardInput,\n  type FindMatchingCardOutput,\n} from './types';\n\nexport async function findMatchingCard(\n  input: FindMatchingCardInput\n): Promise<FindMatchingCardOutput> {\n  return findMatchingCardFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'findMatchingCardPrompt',\n  input: {schema: FindMatchingCardInputSchema},\n  output: {schema: FindMatchingCardOutputSchema},\n  prompt: `You are an arbiter in a historical card game. Your task is to determine if an opponent has a card that matches the current player's request.\n\n  The player is requesting a card with this description:\n  \"{{{request}}}\"\n\n  Here are the cards in the opponent's hand:\n  {{#each opponentHand}}\n  - Card ID: {{{this.id}}}, Name: \"{{{this.name}}}\", Description: \"{{{this.description}}}\"\n  {{/each}}\n\n  Review the opponent's hand. If one of the cards is a reasonable match for the player's request, return the ID of that card and a brief justification. The match should be based on the card's name and description.\n\n  If no card is a good match, return a reason explaining why none of the cards fit the request. Only return a card if it's a strong, direct match. Be strict.\n  `,\n  config: {\n    safetySettings: [\n      {\n        category: 'HARM_CATEGORY_HATE_SPEECH',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_HARASSMENT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n        threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n      },\n    ],\n  },\n});\n\nconst findMatchingCardFlow = ai.defineFlow(\n  {\n    name: 'findMatchingCardFlow',\n    inputSchema: FindMatchingCardInputSchema,\n    outputSchema: FindMatchingCardOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;CAIC,GAED;AAEA;;;;;;AAOO,eAAe,iBACpB,KAA4B;IAE5B,OAAO,qBAAqB;AAC9B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ,2HAAA,CAAA,8BAA2B;IAAA;IAC3C,QAAQ;QAAC,QAAQ,2HAAA,CAAA,+BAA4B;IAAA;IAC7C,QAAQ,CAAC;;;;;;;;;;;;;EAaT,CAAC;IACD,QAAQ;QACN,gBAAgB;YACd;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;SACD;IACH;AACF;AAEA,MAAM,uBAAuB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACxC;IACE,MAAM;IACN,aAAa,2HAAA,CAAA,8BAA2B;IACxC,cAAc,2HAAA,CAAA,+BAA4B;AAC5C,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAvDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/verify-hist-set.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent for verifying if a set of 4 cards constitutes a valid \"Hist Set\".\n *\n * - verifyHistSet - A function that verifies the historical connection of a 4-card set.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {\n  VerifyHistSetInputSchema,\n  VerifyHistSetOutputSchema,\n  type VerifyHistSetInput,\n  type VerifyHistSetOutput,\n} from './types';\n\nexport async function verifyHistSet(\n  input: VerifyHistSetInput\n): Promise<VerifyHistSetOutput> {\n  return verifyHistSetFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'verifyHistSetPrompt',\n  input: {schema: VerifyHistSetInputSchema},\n  output: {schema: VerifyHistSetOutputSchema},\n  prompt: `You are an expert historian and the arbiter of the card game \"Go Hist!\". Your task is to determine if a player's proposed set of 4 cards is a valid \"Hist Set\".\n\n  A valid \"Hist Set\" must follow two rules:\n  1.  The set must contain at least one \"Person\" card.\n  2.  The four cards must have a clear, direct, and verifiable historical connection. The connection must be explained by the player. It is acceptable for a set to contain multiple \"Person\" cards, as long as their connection is justified by common events or relationships.\n\n  Here are the 4 cards the player has proposed:\n  {{#each cards}}\n  - Card Name: \"{{this.name}}\", Type: \"{{this.type}}\", Description: \"{{this.description}}\"\n  {{/each}}\n\n  Here is the player's explanation for the connection:\n  \"{{{explanation}}}\"\n\n  First, check if there is at least one \"Person\" card in the set. If not, the set is invalid.\n  \n  Next, critically evaluate the player's explanation. Is the historical connection strong, logical, and accurate? Be strict. Vague or tangential connections are not allowed. For example, simply stating that two people were alive at the same time is not a valid connection. There must be a direct link, such as collaboration, conflict, or influence.\n\n  Based on your evaluation, decide if the set is valid. Provide a clear reason for your decision, either confirming the valid connection or explaining why it is invalid.\n  `,\n  config: {\n    safetySettings: [\n      {\n        category: 'HARM_CATEGORY_HATE_SPEECH',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_HARASSMENT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n        threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n      },\n    ],\n  },\n});\n\nconst verifyHistSetFlow = ai.defineFlow(\n  {\n    name: 'verifyHistSetFlow',\n    inputSchema: VerifyHistSetInputSchema,\n    outputSchema: VerifyHistSetOutputSchema,\n  },\n  async input => {\n    // Rule 1: Check for at least one Person card\n    const hasPersonCard = input.cards.some(card => card.type === 'Person');\n    if (!hasPersonCard) {\n      return {\n        isValid: false,\n        reason: 'The proposed set is invalid because it does not contain at least one \"Person\" card.',\n      };\n    }\n    \n    // If the rule is met, proceed with AI validation\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;CAIC,GAED;AACA;;;;;;AAOO,eAAe,cACpB,KAAyB;IAEzB,OAAO,kBAAkB;AAC3B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ,2HAAA,CAAA,2BAAwB;IAAA;IACxC,QAAQ;QAAC,QAAQ,2HAAA,CAAA,4BAAyB;IAAA;IAC1C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;EAmBT,CAAC;IACD,QAAQ;QACN,gBAAgB;YACd;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;SACD;IACH;AACF;AAEA,MAAM,oBAAoB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACrC;IACE,MAAM;IACN,aAAa,2HAAA,CAAA,2BAAwB;IACrC,cAAc,2HAAA,CAAA,4BAAyB;AACzC,GACA,OAAM;IACJ,6CAA6C;IAC7C,MAAM,gBAAgB,MAAM,KAAK,CAAC,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;IAC7D,IAAI,CAAC,eAAe;QAClB,OAAO;YACL,SAAS;YACT,QAAQ;QACV;IACF;IAEA,iDAAiD;IACjD,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAvEoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 591, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/get-ai-player-action.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent that determines the best action for an AI player to take on their turn.\n *\n * - getAiPlayerAction - A function that returns the best action for an AI player.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {GetAiPlayerActionInputSchema, GetAiPlayerActionOutputSchema, type GetAiPlayerActionInput, type GetAiPlayerActionOutput} from './types';\n\n\nexport async function getAiPlayerAction(\n  input: GetAiPlayerActionInput\n): Promise<GetAiPlayerActionOutput> {\n  return getAiPlayerActionFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'getAiPlayerActionPrompt',\n  input: {schema: GetAiPlayerActionInputSchema},\n  output: {schema: GetAiPlayerActionOutputSchema},\n  prompt: `You are an AI player in the card game \"Go Hist!\". It is your turn to act. Analyze your hand and the current game state to decide the best strategic move.\n\n  Your Name: {{{playerName}}}\n\n  Your Hand:\n  {{#each hand}}\n  - Card ID: {{{this.id}}}, Name: \"{{{this.name}}}\", Description: \"{{{this.description}}}\"\n  {{/each}}\n\n  Your Goal: Form a \"Hist Set\" of 4 cards with a strong historical connection.\n\n  Game State:\n  - Your current Hist Sets: {{histSetCount}}\n  - Other Players:\n  {{#each otherPlayers}}\n    - {{{this.name}}} (has {{{this.handSize}}} cards and {{{this.histSetCount}}} sets)\n  {{/each}}\n  - Card on top of Discard Pile: {{#if discardTopCard}}\"{{discardTopCard.name}}\"{{else}}Empty{{/if}}\n\n  Available Actions:\n  1.  **Form a Hist Set**: If you have 4 cards in your hand that form a valid historical set, you can declare it.\n      - If you choose this, set 'action' to 'formSet'.\n      - Provide the IDs of the 4 cards in 'cardIds'.\n      - Provide a brief, convincing 'explanation' for the historical connection.\n  2.  **Ask for a Card**: You can ask another player for a specific card to help you complete a potential set.\n      - If you choose this, set 'action' to 'ask'.\n      - Specify the 'opponentId' you are asking.\n      - Create a clear 'request' string for the card you need (e.g., \"a leader from the American Revolution\" or \"an event related to space exploration\").\n  3.  **Draw a Card**: If you cannot make a strong move, you can draw from the deck or the discard pile.\n      - If you choose to draw from the deck, set 'action' to 'drawDeck'.\n      - If you want the top card of the discard pile, set 'action' to 'drawDiscard'. Only do this if the card is genuinely useful for a potential set.\n\n  Decision Strategy:\n  - **Priority 1 (Winning Move)**: If you can form a Hist Set that will win you the game (i.e., you reach the winning number of sets), take it immediately.\n  - **Priority 2 (Form a Set)**: If you have a definite, strong Hist Set in your hand, declare it. This is your primary way to score points. Be confident in the connection.\n  - **Priority 3 (Ask for a Card)**: If you have 3 cards that are very close to forming a set, ask an opponent for a card that would complete it. Target opponents who are close to winning or who you think might have the card.\n  - **Priority 4 (Draw)**: If the above options aren't viable, draw a card. Prefer the discard pile only if the top card directly helps you build a strong potential set (e.g., you have 2-3 cards that connect to it). Otherwise, draw from the main deck for a new, random card.\n\n  Based on your hand and the game state, determine the single best action to take right now.\n  `,\n});\n\nconst getAiPlayerActionFlow = ai.defineFlow(\n  {\n    name: 'getAiPlayerActionFlow',\n    inputSchema: GetAiPlayerActionInputSchema,\n    outputSchema: GetAiPlayerActionOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;CAIC,GAED;AACA;;;;;;AAGO,eAAe,kBACpB,KAA6B;IAE7B,OAAO,sBAAsB;AAC/B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ,2HAAA,CAAA,+BAA4B;IAAA;IAC5C,QAAQ;QAAC,QAAQ,2HAAA,CAAA,gCAA6B;IAAA;IAC9C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAuCT,CAAC;AACH;AAEA,MAAM,wBAAwB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACzC;IACE,MAAM;IACN,aAAa,2HAAA,CAAA,+BAA4B;IACzC,cAAc,2HAAA,CAAA,gCAA6B;AAC7C,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IA7DoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 678, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/game/actions.ts"],"sourcesContent":["'use server';\n\nimport { verifyHistoricalConnection, VerifyHistoricalConnectionInput, VerifyHistoricalConnectionOutput } from '@/ai/flows/verify-historical-connection';\nimport { findMatchingCard } from '@/ai/flows/find-matching-card';\nimport type { FindMatchingCardInput, FindMatchingCardOutput, VerifyHistSetInput, VerifyHistSetOutput, GetAiPlayerActionInput, GetAiPlayerActionOutput } from '@/ai/flows/types';\nimport { verifyHistSet } from '@/ai/flows/verify-hist-set';\nimport { getAiPlayerAction } from '@/ai/flows/get-ai-player-action';\n\n\nexport async function verifyConnectionAction(input: VerifyHistoricalConnectionInput): Promise<VerifyHistoricalConnectionOutput> {\n  try {\n    const result = await verifyHistoricalConnection(input);\n    return result;\n  } catch (error) {\n    console.error('Error verifying connection:', error);\n    return {\n      isValid: false,\n      reason: 'An error occurred while communicating with the historian AI. Please try again.',\n    };\n  }\n}\n\nexport async function findMatchingCardAction(input: FindMatchingCardInput): Promise<FindMatchingCardOutput> {\n    try {\n        const result = await findMatchingCard(input);\n        return result;\n    } catch (error) {\n        console.error('Error finding matching card:', error);\n        return {\n            cardId: undefined,\n            reason: 'An error occurred while communicating with the arbiter AI. Please try again.',\n        };\n    }\n}\n\nexport async function verifyHistSetAction(input: VerifyHistSetInput): Promise<VerifyHistSetOutput> {\n    try {\n        const result = await verifyHistSet(input);\n        return result;\n    } catch (error) {\n        console.error('Error verifying Hist Set:', error);\n        return {\n            isValid: false,\n            reason: 'An error occurred while communicating with the historian AI. Please try again.',\n        };\n    }\n}\n\n\nexport async function getAiPlayerActionAction(input: GetAiPlayerActionInput): Promise<GetAiPlayerActionOutput> {\n    try {\n        const result = await getAiPlayerAction(input);\n        return result;\n    } catch (error) {\n        console.error('Error getting AI player action:', error);\n        // Default to drawing from the deck on error\n        return {\n            action: 'drawDeck'\n        };\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAEA;AACA;AAEA;AACA;;;;;;;;AAGO,eAAe,uBAAuB,KAAsC;IACjF,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,wJAAA,CAAA,6BAA0B,AAAD,EAAE;QAChD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YACL,SAAS;YACT,QAAQ;QACV;IACF;AACF;AAEO,eAAe,uBAAuB,KAA4B;IACrE,IAAI;QACA,MAAM,SAAS,MAAM,CAAA,GAAA,8IAAA,CAAA,mBAAgB,AAAD,EAAE;QACtC,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;YACH,QAAQ;YACR,QAAQ;QACZ;IACJ;AACJ;AAEO,eAAe,oBAAoB,KAAyB;IAC/D,IAAI;QACA,MAAM,SAAS,MAAM,CAAA,GAAA,2IAAA,CAAA,gBAAa,AAAD,EAAE;QACnC,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YACH,SAAS;YACT,QAAQ;QACZ;IACJ;AACJ;AAGO,eAAe,wBAAwB,KAA6B;IACvE,IAAI;QACA,MAAM,SAAS,MAAM,CAAA,GAAA,mJAAA,CAAA,oBAAiB,AAAD,EAAE;QACvC,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mCAAmC;QACjD,4CAA4C;QAC5C,OAAO;YACH,QAAQ;QACZ;IACJ;AACJ;;;IAnDsB;IAaA;IAaA;IAcA;;AAxCA,+OAAA;AAaA,+OAAA;AAaA,+OAAA;AAcA,+OAAA","debugId":null}},
    {"offset": {"line": 762, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/game/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {findMatchingCardAction as '402e3b7add7b9be4f67164dfc4473eadb3cc247645'} from 'ACTIONS_MODULE0'\nexport {getAiPlayerActionAction as '4013ecd32771ca5a5cb4631dbc43b0a7f3836926e5'} from 'ACTIONS_MODULE0'\nexport {verifyHistSetAction as '4037e0f74b22cb4d6205e199f744a28d3b98775534'} from 'ACTIONS_MODULE0'\nexport {verifyConnectionAction as '4046bf87ba69b11beb92cd60b45611f58b805b7d43'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 823, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/game/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/game/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/game/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAyR,GACtT,uDACA","debugId":null}},
    {"offset": {"line": 837, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/game/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/game/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/game/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAqQ,GAClS,mCACA","debugId":null}},
    {"offset": {"line": 851, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}