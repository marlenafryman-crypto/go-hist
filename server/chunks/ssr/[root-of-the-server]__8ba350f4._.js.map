{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/verify-historical-connection.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent for verifying historical connections between cards.\n *\n * - verifyHistoricalConnection - A function that verifies the historical connection explanation.\n * - VerifyHistoricalConnectionInput - The input type for the verifyHistoricalConnection function.\n * - VerifyHistoricalConnectionOutput - The return type for the verifyHistoricalConnection function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst VerifyHistoricalConnectionInputSchema = z.object({\n  card1Name: z.string().describe('The name of the first card.'),\n  card2Name: z.string().describe('The name of the second card.'),\n  explanation: z.string().describe('The explanation of the historical connection between the two cards.'),\n});\nexport type VerifyHistoricalConnectionInput = z.infer<typeof VerifyHistoricalConnectionInputSchema>;\n\nconst VerifyHistoricalConnectionOutputSchema = z.object({\n  isValid: z.boolean().describe('Whether the historical connection explanation is valid.'),\n  reason: z.string().describe('The reasoning behind the validity determination.'),\n});\nexport type VerifyHistoricalConnectionOutput = z.infer<typeof VerifyHistoricalConnectionOutputSchema>;\n\nexport async function verifyHistoricalConnection(input: VerifyHistoricalConnectionInput): Promise<VerifyHistoricalConnectionOutput> {\n  return verifyHistoricalConnectionFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'verifyHistoricalConnectionPrompt',\n  input: {schema: VerifyHistoricalConnectionInputSchema},\n  output: {schema: VerifyHistoricalConnectionOutputSchema},\n  prompt: `You are an expert historian. You will be given two cards, and an explanation of how they are historically connected.\nYour job is to determine whether the explanation is valid, and provide a reason for your determination.\n\nCard 1: {{{card1Name}}}\nCard 2: {{{card2Name}}}\nExplanation: {{{explanation}}}\n\nIs the explanation valid? Answer in the following JSON format:\n{\n  \"isValid\": boolean,\n  \"reason\": string\n}`,\n  config: {\n    safetySettings: [\n      {\n        category: 'HARM_CATEGORY_HATE_SPEECH',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_HARASSMENT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n        threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n      },\n    ],\n  },\n});\n\nconst verifyHistoricalConnectionFlow = ai.defineFlow(\n  {\n    name: 'verifyHistoricalConnectionFlow',\n    inputSchema: VerifyHistoricalConnectionInputSchema,\n    outputSchema: VerifyHistoricalConnectionOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,wCAAwC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACrD,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACnC;AAGA,MAAM,yCAAyC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACtD,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B;AAGO,eAAe,2BAA2B,KAAsC;IACrF,OAAO,+BAA+B;AACxC;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ;IAAqC;IACrD,QAAQ;QAAC,QAAQ;IAAsC;IACvD,QAAQ,CAAC;;;;;;;;;;;CAWV,CAAC;IACA,QAAQ;QACN,gBAAgB;YACd;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;SACD;IACH;AACF;AAEA,MAAM,iCAAiC,mHAAA,CAAA,KAAE,CAAC,UAAU,CAClD;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAnDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 335, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/types.ts"],"sourcesContent":["import {z} from 'genkit';\n\nconst CardSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['Person', 'Event']),\n  description: z.string(),\n});\nexport type Card = z.infer<typeof CardSchema>;\n\nexport const FindMatchingCardInputSchema = z.object({\n  request: z\n    .string()\n    .describe('The textual request for a card from the current player.'),\n  opponentHand: z\n    .array(CardSchema)\n    .describe(\"An array of card objects in the opponent's hand.\"),\n});\nexport type FindMatchingCardInput = z.infer<typeof FindMatchingCardInputSchema>;\n\nexport const FindMatchingCardOutputSchema = z.object({\n  cardId: z\n    .string()\n    .optional()\n    .describe(\n      \"The ID of the card in the opponent's hand that matches the request. If no card matches, this will be undefined.\"\n    ),\n  reason: z\n    .string()\n    .describe(\n      'A brief explanation of why the card matches the request, or why no card matches.'\n    ),\n});\nexport type FindMatchingCardOutput = z.infer<\n  typeof FindMatchingCardOutputSchema\n>;\n\nexport const VerifyHistSetInputSchema = z.object({\n    cards: z.array(CardSchema).length(4).describe('The four cards being checked for a valid Hist Set.'),\n    explanation: z.string().describe('The player\\'s explanation of the historical connection between the four cards.'),\n});\nexport type VerifyHistSetInput = z.infer<typeof VerifyHistSetInputSchema>;\n\nexport const VerifyHistSetOutputSchema = z.object({\n    isValid: z.boolean().describe('Whether the historical connection explanation is valid and follows the rules.'),\n    reason: z.string().describe('The reasoning behind the validity determination.'),\n});\nexport type VerifyHistSetOutput = z.infer<typeof VerifyHistSetOutputSchema>;\n\nexport const VerifyHistoricalConnectionInputSchema = z.object({\n  card1Name: z.string().describe('The name of the first card.'),\n  card2Name: z.string().describe('The name of the second card.'),\n  explanation: z.string().describe('The explanation of the historical connection between the two cards.'),\n});\nexport type VerifyHistoricalConnectionInput = z.infer<typeof VerifyHistoricalConnectionInputSchema>;\n\nexport const VerifyHistoricalConnectionOutputSchema = z.object({\n  isValid: z.boolean().describe('Whether the historical connection explanation is valid.'),\n  reason: z.string().describe('The reasoning behind the validity determination.'),\n});\nexport type VerifyHistoricalConnectionOutput = z.infer<typeof VerifyHistoricalConnectionOutputSchema>;\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;;AAEA,MAAM,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC1B,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM;IACZ,MAAM,uIAAA,CAAA,IAAC,CAAC,MAAM;IACd,MAAM,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAU;KAAQ;IAChC,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM;AACvB;AAGO,MAAM,8BAA8B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClD,SAAS,uIAAA,CAAA,IAAC,CACP,MAAM,GACN,QAAQ,CAAC;IACZ,cAAc,uIAAA,CAAA,IAAC,CACZ,KAAK,CAAC,YACN,QAAQ,CAAC;AACd;AAGO,MAAM,+BAA+B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnD,QAAQ,uIAAA,CAAA,IAAC,CACN,MAAM,GACN,QAAQ,GACR,QAAQ,CACP;IAEJ,QAAQ,uIAAA,CAAA,IAAC,CACN,MAAM,GACN,QAAQ,CACP;AAEN;AAKO,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7C,OAAO,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,YAAY,MAAM,CAAC,GAAG,QAAQ,CAAC;IAC9C,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACrC;AAGO,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC9C,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAChC;AAGO,MAAM,wCAAwC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC5D,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACnC;AAGO,MAAM,yCAAyC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAC7D,SAAS,uIAAA,CAAA,IAAC,CAAC,OAAO,GAAG,QAAQ,CAAC;IAC9B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC9B","debugId":null}},
    {"offset": {"line": 386, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/find-matching-card.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent for finding a matching card in a player's hand based on a request.\n *\n * - findMatchingCard - A function that checks if any card in a hand matches a given request.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\nimport {\n  FindMatchingCardInputSchema,\n  FindMatchingCardOutputSchema,\n  type FindMatchingCardInput,\n  type FindMatchingCardOutput,\n} from './types';\n\nexport async function findMatchingCard(\n  input: FindMatchingCardInput\n): Promise<FindMatchingCardOutput> {\n  return findMatchingCardFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'findMatchingCardPrompt',\n  input: {schema: FindMatchingCardInputSchema},\n  output: {schema: FindMatchingCardOutputSchema},\n  prompt: `You are an arbiter in a historical card game. Your task is to determine if an opponent has a card that matches the current player's request.\n\n  The player is requesting a card with this description:\n  \"{{{request}}}\"\n\n  Here are the cards in the opponent's hand:\n  {{#each opponentHand}}\n  - Card ID: {{{this.id}}}, Name: \"{{{this.name}}}\", Description: \"{{{this.description}}}\"\n  {{/each}}\n\n  Review the opponent's hand. If one of the cards is a reasonable match for the player's request, return the ID of that card and a brief justification. The match should be based on the card's name and description.\n\n  If no card is a good match, return a reason explaining why none of the cards fit the request. Only return a card if it's a strong, direct match. Be strict.\n  `,\n  config: {\n    safetySettings: [\n      {\n        category: 'HARM_CATEGORY_HATE_SPEECH',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_HARASSMENT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n        threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n      },\n    ],\n  },\n});\n\nconst findMatchingCardFlow = ai.defineFlow(\n  {\n    name: 'findMatchingCardFlow',\n    inputSchema: FindMatchingCardInputSchema,\n    outputSchema: FindMatchingCardOutputSchema,\n  },\n  async input => {\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;CAIC,GAED;AAEA;;;;;;AAOO,eAAe,iBACpB,KAA4B;IAE5B,OAAO,qBAAqB;AAC9B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ,2HAAA,CAAA,8BAA2B;IAAA;IAC3C,QAAQ;QAAC,QAAQ,2HAAA,CAAA,+BAA4B;IAAA;IAC7C,QAAQ,CAAC;;;;;;;;;;;;;EAaT,CAAC;IACD,QAAQ;QACN,gBAAgB;YACd;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;SACD;IACH;AACF;AAEA,MAAM,uBAAuB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACxC;IACE,MAAM;IACN,aAAa,2HAAA,CAAA,8BAA2B;IACxC,cAAc,2HAAA,CAAA,+BAA4B;AAC5C,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAvDoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 467, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/verify-hist-set.ts"],"sourcesContent":["'use server';\n\n/**\n * @fileOverview An AI agent for verifying if a set of 4 cards constitutes a valid \"Hist Set\".\n *\n * - verifyHistSet - A function that verifies the historical connection of a 4-card set.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {\n  VerifyHistSetInputSchema,\n  VerifyHistSetOutputSchema,\n  type VerifyHistSetInput,\n  type VerifyHistSetOutput,\n} from './types';\n\nexport async function verifyHistSet(\n  input: VerifyHistSetInput\n): Promise<VerifyHistSetOutput> {\n  return verifyHistSetFlow(input);\n}\n\nconst prompt = ai.definePrompt({\n  name: 'verifyHistSetPrompt',\n  input: {schema: VerifyHistSetInputSchema},\n  output: {schema: VerifyHistSetOutputSchema},\n  prompt: `You are an expert historian and the arbiter of the card game \"Go Hist!\". Your task is to determine if a player's proposed set of 4 cards is a valid \"Hist Set\".\n\n  A valid \"Hist Set\" must follow two rules:\n  1.  The set must contain at least one \"Person\" card.\n  2.  The four cards must have a clear, direct, and verifiable historical connection. The connection must be explained by the player. It is acceptable for a set to contain multiple \"Person\" cards, as long as their connection is justified by common events or relationships.\n\n  Here are the 4 cards the player has proposed:\n  {{#each cards}}\n  - Card Name: \"{{this.name}}\", Type: \"{{this.type}}\", Description: \"{{this.description}}\"\n  {{/each}}\n\n  Here is the player's explanation for the connection:\n  \"{{{explanation}}}\"\n\n  First, check if there is at least one \"Person\" card in the set. If not, the set is invalid.\n  \n  Next, critically evaluate the player's explanation. Is the historical connection strong, logical, and accurate? Be strict. Vague or tangential connections are not allowed. For example, simply stating that two people were alive at the same time is not a valid connection. There must be a direct link, such as collaboration, conflict, or influence.\n\n  Based on your evaluation, decide if the set is valid. Provide a clear reason for your decision, either confirming the valid connection or explaining why it is invalid.\n  `,\n  config: {\n    safetySettings: [\n      {\n        category: 'HARM_CATEGORY_HATE_SPEECH',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_HARASSMENT',\n        threshold: 'BLOCK_LOW_AND_ABOVE',\n      },\n      {\n        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',\n        threshold: 'BLOCK_MEDIUM_AND_ABOVE',\n      },\n    ],\n  },\n});\n\nconst verifyHistSetFlow = ai.defineFlow(\n  {\n    name: 'verifyHistSetFlow',\n    inputSchema: VerifyHistSetInputSchema,\n    outputSchema: VerifyHistSetOutputSchema,\n  },\n  async input => {\n    // Rule 1: Check for at least one Person card\n    const hasPersonCard = input.cards.some(card => card.type === 'Person');\n    if (!hasPersonCard) {\n      return {\n        isValid: false,\n        reason: 'The proposed set is invalid because it does not contain at least one \"Person\" card.',\n      };\n    }\n    \n    // If the rule is met, proceed with AI validation\n    const {output} = await prompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AAEA;;;;CAIC,GAED;AACA;;;;;;AAOO,eAAe,cACpB,KAAyB;IAEzB,OAAO,kBAAkB;AAC3B;AAEA,MAAM,SAAS,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAC7B,MAAM;IACN,OAAO;QAAC,QAAQ,2HAAA,CAAA,2BAAwB;IAAA;IACxC,QAAQ;QAAC,QAAQ,2HAAA,CAAA,4BAAyB;IAAA;IAC1C,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;EAmBT,CAAC;IACD,QAAQ;QACN,gBAAgB;YACd;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;YACA;gBACE,UAAU;gBACV,WAAW;YACb;SACD;IACH;AACF;AAEA,MAAM,oBAAoB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACrC;IACE,MAAM;IACN,aAAa,2HAAA,CAAA,2BAAwB;IACrC,cAAc,2HAAA,CAAA,4BAAyB;AACzC,GACA,OAAM;IACJ,6CAA6C;IAC7C,MAAM,gBAAgB,MAAM,KAAK,CAAC,IAAI,CAAC,CAAA,OAAQ,KAAK,IAAI,KAAK;IAC7D,IAAI,CAAC,eAAe;QAClB,OAAO;YACL,SAAS;YACT,QAAQ;QACV;IACF;IAEA,iDAAiD;IACjD,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,OAAO;IAC9B,OAAO;AACT;;;IAvEoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/game/actions.ts"],"sourcesContent":["'use server';\n\nimport { verifyHistoricalConnection, VerifyHistoricalConnectionInput, VerifyHistoricalConnectionOutput } from '@/ai/flows/verify-historical-connection';\nimport { findMatchingCard } from '@/ai/flows/find-matching-card';\nimport type { FindMatchingCardInput, FindMatchingCardOutput, VerifyHistSetInput, VerifyHistSetOutput } from '@/ai/flows/types';\nimport { verifyHistSet } from '@/ai/flows/verify-hist-set';\n\n\nexport async function verifyConnectionAction(input: VerifyHistoricalConnectionInput): Promise<VerifyHistoricalConnectionOutput> {\n  try {\n    const result = await verifyHistoricalConnection(input);\n    return result;\n  } catch (error) {\n    console.error('Error verifying connection:', error);\n    return {\n      isValid: false,\n      reason: 'An error occurred while communicating with the historian AI. Please try again.',\n    };\n  }\n}\n\nexport async function findMatchingCardAction(input: FindMatchingCardInput): Promise<FindMatchingCardOutput> {\n    try {\n        const result = await findMatchingCard(input);\n        return result;\n    } catch (error) {\n        console.error('Error finding matching card:', error);\n        return {\n            cardId: undefined,\n            reason: 'An error occurred while communicating with the arbiter AI. Please try again.',\n        };\n    }\n}\n\nexport async function verifyHistSetAction(input: VerifyHistSetInput): Promise<VerifyHistSetOutput> {\n    try {\n        const result = await verifyHistSet(input);\n        return result;\n    } catch (error) {\n        console.error('Error verifying Hist Set:', error);\n        return {\n            isValid: false,\n            reason: 'An error occurred while communicating with the historian AI. Please try again.',\n        };\n    }\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AAEA;;;;;;;AAGO,eAAe,uBAAuB,KAAsC;IACjF,IAAI;QACF,MAAM,SAAS,MAAM,CAAA,GAAA,wJAAA,CAAA,6BAA0B,AAAD,EAAE;QAChD,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO;YACL,SAAS;YACT,QAAQ;QACV;IACF;AACF;AAEO,eAAe,uBAAuB,KAA4B;IACrE,IAAI;QACA,MAAM,SAAS,MAAM,CAAA,GAAA,8IAAA,CAAA,mBAAgB,AAAD,EAAE;QACtC,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,OAAO;YACH,QAAQ;YACR,QAAQ;QACZ;IACJ;AACJ;AAEO,eAAe,oBAAoB,KAAyB;IAC/D,IAAI;QACA,MAAM,SAAS,MAAM,CAAA,GAAA,2IAAA,CAAA,gBAAa,AAAD,EAAE;QACnC,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO;YACH,SAAS;YACT,QAAQ;QACZ;IACJ;AACJ;;;IArCsB;IAaA;IAaA;;AA1BA,+OAAA;AAaA,+OAAA;AAaA,+OAAA","debugId":null}},
    {"offset": {"line": 630, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/game/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {findMatchingCardAction as '402e3b7add7b9be4f67164dfc4473eadb3cc247645'} from 'ACTIONS_MODULE0'\nexport {verifyConnectionAction as '4046bf87ba69b11beb92cd60b45611f58b805b7d43'} from 'ACTIONS_MODULE0'\nexport {verifyHistSetAction as '4037e0f74b22cb4d6205e199f744a28d3b98775534'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 688, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/game/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/game/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/game/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAyR,GACtT,uDACA","debugId":null}},
    {"offset": {"line": 702, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/game/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/game/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/game/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAqQ,GAClS,mCACA","debugId":null}},
    {"offset": {"line": 716, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}